#  迭代器是一个更抽象的概念，任何对象，如果它的类有next 方法和iter方法返回自己本身，对于 string、list、dict、tuple 等这类容器对象，使用 for 循环遍历是很方便的。在后台 for 语句对容器对象调用iter()函数，iter()是 python 的内置函数。iter()会返回一个定义了 next()方法的迭代器对象，它在容器中逐个访问容器内元素，next()也是 python 的内置函数。在没有后续元素时，next()会抛出一个StopIteration 异常
#
# 生成器（Generator）是创建迭代器的简单而强大的工具。它们写起来就像是正规的函数，只是在需要返回数据的时候使用yield语句。每次next()被调用时，生成器会返回它脱离的位置（它记忆语句最后一次执行的位置和所有的数据值）
#
# 区别：生成器能做到迭代器能做的所有事,而且因为自动创建了iter()和next()方法,生成器显得特别简洁,而且生成器也是高效的，使用生成器表达式取代列表解析可以同时节省内存。除了创建和保存程序状态的自动方法,当发生器终结时,还会自动抛StopIteration异常。

# yield 就是保存当前程序执行状态。你用
# for 循环的时候，每次取一个元素的时候就会计算一次。用 yield 的函数叫 generator，和 iterator 一样，它的好处是不用一次计算所有元素，而是用一次算一次，可以节省很多空间。generator每次计算需要上一次计算结果，所以用 yield ，否则一 return ，上次计算结果就没了


# 如何更好地理解Python迭代器和生成器？：https://www.zhihu.com/question/20829330

# 3、Python 生成器 和迭代器的区别？
# 作为迭代器必须实现两个特定的方法 “__iter__()，__next__()” ；
# 生成器是一种特许的迭代器，支持所有的迭代操作，除此之外生成器还实现了，普通迭代器没有的一些特性；
# 比如说它可以通过 send 的方法与生成器内部进行数据交互；还有它可以通过 close 方法去进行关闭；甚至还可以通过 throw 方法，引发内部的异常；