#因为python的内存管理是通过引用计数的，这个引用计数变量需要在两个线程同时增加或减少时从竞争条件中得到保护。如果发生了这种情况，可能会导致泄露的内存永远不会被释放，抑或更严重的是当一个对象的引用仍然存在的情况下错误地释放内存。这可能会导致Python程序崩溃或带来各种诡异的bug。
#什么是python的全局解释锁（GIL）?：https://blog.csdn.net/Beyond_F4/article/details/79951226